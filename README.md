play-elastic4s [![Build Status](https://travis-ci.org/evojam/play-elastic4s.svg?branch=master)](https://travis-ci.org/evojam/play-elastic4s)
===========================

We've been using [elastic4s](https://github.com/sksamuel/elastic4s) with [Play framework](https://www.playframework.com/) for a while.
Without convenient way of configuration and injecting ElasticClient instance there was a lot boilerplate work to do.
This module enhances elastic4s with two main features:

1. Loading driver configuration from `application.conf`.
1. Automatic JSON conversions for Elasticsearch based on [Play JSON formatters](https://www.playframework.com/documentation/2.4.x/ScalaJson).

As a bonus, the Elasticsearch driver will automatically disconnect on Play application shutdown.


Quick Start
-----------

There are no stable releases yet. We're testing the current version
with Elasticsearch 2.2.0 and it will not work with Elasticsearch other
than 2.2.X. Moreover, we depend on Play 2.4.3 which in turn requires Java 8.

### 1. Installation


Add the dependency to your `build.sbt`:

	libraryDependencies += "com.evojam" %% "play-elastic4s" % "0.2.1-SNAPSHOT"

	resolvers += Resolver.sonatypeRepo("snapshots")


### 2. Setup

Extend your application.conf to load the module and get all goodies injectable:

```hocon
elastic4s {
		clusters {
				myCluster {
					 uri: elasticsearch://host:port  // <-- pass something useful here
					 cluster.name: "mycluster"       // <-- and here
				}
		}
		indexAndTypes {                        // <-- this section is not required, but
				book {                             //     this index/type pair will be injectable later
						index: "library"
						type: "book"
				}
		}
}

play.modules.enabled += "com.evojam.play.elastic4s.Elastic4sModule"
```

You may define any number of clusters. Each of them needs to have the two above
fields. Any other fields will be passed to Elasticsearch Java driver
(see [Transport Client docs](https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/transport-client.html)).

You may use the `indexAndTypes` node to configure names of your indices in ES.
As a good practice, you should probably put aliases here, not hard names
(refer to [ES docs on aliases](https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html)). Every key in that node will be transformed to
an injectable [`IndexAndType`](https://github.com/sksamuel/elastic4s/blob/master/elastic4s-core/src/main/scala/com/sksamuel/elastic4s/IndexAndTypes.scala) instance.

### 3. Enjoy injectable configuration

Instead of instantiating `ElasticClient` manually, have the configuration
and our factory [injected](https://www.playframework.com/documentation/2.4.x/ScalaDependencyInjection):

```scala

class BookDao @Inject()(
	cs: ClusterSetup,
	elasticFactory: PlayElasticFactory,
	@Named("book") indexAndType: IndexAndType) extends
		ElasticDsl {

	private[this] lazy val client = elasticFactory(cs)

	def searchByAnything(q: String): Future[RichSearchResponse] = client execute {
		search in indexAndType query q
	}
}
```

Apart from the injection, nothing changes. The `client` generated by the factory is a regular `ElasticClient` from `elastic4s` library,
so all the original API stays. Calling the factory twice with the same `ClusterSetup`
will reuse the same client, so feel free to use the factory whenever you need
a client instance. Moreover, the created client instances are hooked to Play
application lifecycle and will gracefully disconnect on application shutdown.

### 4. Enjoy seamless JSON conversions

The original elastic4s API already provides automatic JSON conversions, but it requires you to provide
specific typeclasses ([Indexable](https://github.com/sksamuel/elastic4s#indexing-from-classes)
and [HitAs](https://github.com/sksamuel/elastic4s#search-conversion)). Play-elastic4s will derive them automatically
based on your Play JSON formatters - just mix in the `PlayElasticJsonSupport` trait:

```scala
case class Book(title: String, author: String, publishDate: DateTime)
object Book {
	implicit val format: Format[Book] = Json.format[Book]
}

class BookDao @Inject()(
	cs: ClusterSetup,
	elasticFactory: PlayElasticFactory,
	@Named("book") indexAndType: IndexAndType) extends
		ElasticDsl with
		PlayElasticJsonSupport {

	private[this] lazy val client = elasticFactory(cs)

	def searchByAnything(q: String): Future[Array[Book]] = client execute {
		search in indexAndType query q
	} map (_.as[Book])   // here the conversion happens. Will throw if documents are malformed.

	def add(bookId: String, book: Book) = client execute {
		index into indexAndType source book id bookId
	}

	// as an extra, you also get an extension method when getting by ID.
	// It returns None if there is no document with the given ID
	// and throws an exception if the document cannot be parsed:
	def getById(bookId: String): Future[Option[Book]] = client.execute {
		get id bookId from indexAndType
	} map (_.as[Book])
}
```

Note that this does not provide interoperability with the magic ES fields
(`_type`, `_id` and similar). Even worse, if your custom type produces
an `_id` field during serialization to JSON, the driver will produce
a request with `_id` field in the source document. Such requests are invalid
and will be rejected.

Advanced usage
--------------------------

### Detailed ES connection configuration
Simply add more options to "elastic4s.clusters.<your-cluster>" node in the config file.
They will be passed to the ES java driver.

### Using mutliple ES clusters
Specify them all in the config file:

```hocon
elastic4s {
		clusters {
				firstCluster {
					 uri: elasticsearch://main.es.example.com:9300
					 cluster.name: "first-es-cluster"
				}
				loggingCluster {
					uri: elasticsearch://log.es.example.com:9300
					cluster.name: "log-es-cluster"
				}

		}
		indexAndTypes {
				book {
						index: "library"
						type: "book"
				}
		}
}

play.modules.enabled += "com.evojam.play.elastic4s.Elastic4sModule"
```

The unnamed binding for `ClusterSetup` is available only if there is exactly one cluster configured.
With multiple clusters, use `@Named` annotation:

```scala
class BookDao @Inject()(
	@Named("firstCluster") firstCs: ClusterSetup,
	@Named("loggingCluster") loggingCs: ClusterSetup,
	elasticFactory: PlayElasticFactory,
	@Named("book") indexAndType: IndexAndType) extends
		ElasticDsl {

	private[this] lazy val client = elasticFactory(firstCs)
	private[this] lazy val logClient = elasticFactory(loggingCs)
	
	...
}
```

