package com.evojam.play.elastic4s

import play.api.libs.json.{Format, JsValue, Json}

import org.elasticsearch.action.get.GetResponse
import org.elasticsearch.action.search.SearchResponse
import org.elasticsearch.search.{SearchHit, SearchHits}
import org.specs2.ScalaCheck
import org.specs2.matcher.Matchers
import org.specs2.mock.Mockito
import org.specs2.mutable.Specification
import org.specs2.scalacheck.Parameters

import com.sksamuel.elastic4s.{RichSearchResponse, RichGetResponse}

class JsonConversionSpec extends Specification with Matchers with Mockito with ScalaCheck with PlayElasticJsonSupport {
  implicit val params: Parameters = Parameters().verbose
  def jsonToBytes(json: JsValue) = Json.asciiStringify(json).toCharArray.map(_.toByte)

  "JSON play conversions for case classes" should {
    "Convert responses from GET requests" in {
      def fakeGetResponse(json: JsValue) = {
        val jsonArrayBuf = jsonToBytes(json)
        val fakeGetResponse = mock[GetResponse]
        fakeGetResponse.isExists returns true
        fakeGetResponse.getSourceAsBytes returns jsonArrayBuf
        fakeGetResponse
      }
      "When PlayJsonSupport is mixed in" in  {
        "For an easy example" in  {
          val foo = Foo("example-foo", 14)
          val response = fakeGetResponse(Json.obj("name" -> "example-foo", "count" -> 14))
          response.isExists shouldEqual true
          new RichGetResponse(response).as[Foo] shouldEqual Some(foo)
        }
        "For autogenerated cases" in prop { (name: String, count: Int) =>
          val response = fakeGetResponse(Json.obj("name" -> name, "count" -> count))
          new RichGetResponse(response).as[Foo] shouldEqual Some(Foo(name, count))
        }
        "With Nones when there is no source" in {
          val response = fakeGetResponse(Json.obj())
          response.isExists returns false
          new RichGetResponse(response).as[Foo] shouldEqual None
        }
      }
    }

    "Convert responses for search queries" in {

      def fakeSearchResponse(jsons: JsValue*) = {
        def mockHit(json: JsValue) = {
          val hit = mock[SearchHit]
          hit.source returns jsonToBytes(json)
          hit
        }

        def mockHits(jsons: Iterable[JsValue]): SearchHits = {
          val hits = mock[SearchHits]
          hits.getHits returns jsons.map(mockHit).toArray
          hits
        }

        val fakeSearchResponse = mock[SearchResponse]
        fakeSearchResponse.getHits returns mockHits(jsons)
        fakeSearchResponse
      }
      "For lists of results" in prop { input: Array[(String, Int)] =>
        val foos = input map { case (name, count) => Foo(name, count) }
        val jsons = input map { case (name, count) => Json.obj("name" -> name, "count" -> count) }
        val response = fakeSearchResponse(jsons: _*)
        new RichSearchResponse(response).as[Foo] shouldEqual foos
      }
    }
  }
}

case class Foo(name: String, count: Int)
object Foo {
  implicit val fmt: Format[Foo] = Json.format[Foo]
}
