package com.evojam.play.elastic4s

import play.api.libs.json.{Format, JsValue, Json}

import org.elasticsearch.action.get.GetResponse
import org.elasticsearch.action.search.SearchResponse
import org.elasticsearch.search.{SearchHit, SearchHits}
import org.specs2.ScalaCheck
import org.specs2.matcher.Matchers
import org.specs2.mock.Mockito
import org.specs2.mutable.Specification
import org.specs2.scalacheck.Parameters

import com.sksamuel.elastic4s.{ElasticDsl, RichSearchResponse, RichGetResponse}

class JsonConversionSpec extends Specification with Matchers with Mockito with ScalaCheck with PlayElasticJsonSupport {

  def jsonToBytes(json: JsValue) = Json.asciiStringify(json).toCharArray.map(_.toByte)

  def fakeGetResponse(json: JsValue) = {
    val jsonArrayBuf = jsonToBytes(json)
    val fakeGetResponse = mock[GetResponse]
    fakeGetResponse.isExists returns true
    fakeGetResponse.getSourceAsBytes returns jsonArrayBuf
    fakeGetResponse
  }

  def fakeSearchResponse(jsons: JsValue*) = {
    def mockHit(json: JsValue) = {
      val hit = mock[SearchHit]
      hit.source returns jsonToBytes(json)
      hit
    }
    def mockHits(jsons: Iterable[JsValue]): SearchHits = {
      val hits = mock[SearchHits]
      hits.getHits returns jsons.map(mockHit).toArray
      hits
    }
    val fakeSearchResponse = mock[SearchResponse]
    fakeSearchResponse.getHits returns mockHits(jsons)
    fakeSearchResponse
  }

  "Conversion for GET requests" should {
    "correctly parse sample case class" in {
      val foo = Foo("example-foo", 14)
      val response = fakeGetResponse(Json.obj("name" -> "example-foo", "count" -> 14))
      response.isExists shouldEqual true
      new RichGetResponse(response).as[Foo] shouldEqual Some(foo)
    }
    "correctly parse autogenerated cases" in prop { (name: String, count: Int) =>
      val response = fakeGetResponse(Json.obj("name" -> name, "count" -> count))
      new RichGetResponse(response).as[Foo] shouldEqual Some(Foo(name, count))
    }
    "return None if there is no document" in {
      val response = fakeGetResponse(Json.obj())
      response.isExists returns false
      new RichGetResponse(response).as[Foo] shouldEqual None
    }
  }

  "Conversions for search requests" should {

    "Parse arrays of results" in prop { input: Array[(String, Int)] =>
      val foos = input map { case (name, count) => Foo(name, count) }
      val jsons = input map { case (name, count) => Json.obj("name" -> name, "count" -> count) }
      val response = fakeSearchResponse(jsons: _*)
      new RichSearchResponse(response).as[Foo] shouldEqual foos
    }
  }

  "Input classes with Writes[T]" should {
    "Be accepted as documents to be indexed" in prop { (name: String, count: Int) =>
      object FakeClient extends ElasticDsl {
        def indexQuery(foo: Foo) = index into "index" / "foo" source foo
      }
      val foo = Foo(name, count)
      val reqBytes = FakeClient.indexQuery(foo).build.source
      Json.parse(reqBytes.array).as[Foo] shouldEqual foo
    }
  }
}

case class Foo(name: String, count: Int)
object Foo {
  implicit val fmt: Format[Foo] = Json.format[Foo]
}
